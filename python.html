<!DOCTYPE html>
<html lang="en">
    <head>
        <title>
            Python
        </title>
        <meta charset="utf-8">
        <link rel="stylesheet" href="styles.css">
    </head>
    <body>
        <header>
        <h1>Intro to Python</h1>
        
        <style>
            main img {
                text-align: center;
            }
        </style>
        </header>
        <nav>
            <div id="horizontal_nav">
                <ul>
                    <li>
                        <a href="index.html">Home &#10025; </a>
                    </li>
                    <li>
                        <a href="html.html" >HTML &#10025; </a>
                    </li>
                    <li>
                        <a href="css.html" >CSS &#10025; </a>
                    </li>
                    <li>
                        <a href="racket.html">Racket</a>
                    </li>
                    <li>
                        <button onclick="myFunction()">Dark mode!</button>
                    </li>
                </ul>
            </div>
            <div id="vert_nav">
                <ul>
                    <li>
                        <a>Programming Tips</a>
                    </li>
                    <li>
                        <a>Background</a>
                    </li>
                    <li>
                        <a>&nbsp; &nbsp; .py</a>
                    </li>
                    <li>
                        <a>&nbsp; &nbsp; Formal and Natural Languages</a>
                    </li>
                    <li>
                        <a>How to Actually Code</a>
                    </li>
                    <li>
                        <a>&nbsp; &nbsp; Basic Computations</a>
                    </li>
                    <li>
                        <a>&nbsp; &nbsp; Bugs and Errors</a>
                    </li>
                    <li>
                        <a>&nbsp; &nbsp; Comments</a>
                    </li>
                   <li>
                    <a>&nbsp; &nbsp; Variables</a>
                   </li> 
                   <li>
                    <a>&nbsp; &nbsp; Data Types</a>
                   </li>
                   <li>
                    <a>&nbsp; &nbsp; More on Strings</a>
                   </li>
                   <li>
                    <a>&nbsp; &nbsp; Lists</a>
                   </li>
                   <li>
                    <a>&nbsp; &nbsp; List Comprehensions </a>
                   </li>
                   <li>
                    <a>&nbsp; &nbsp; Tuples </a>
                   </li>
                   <li>
                    <a>&nbsp; &nbsp; Using Files </a>
                   </li>
                   <li>
                    <a>&nbsp; &nbsp; Statements vs Expressions</a>
                   </li>
                   <li>
                    <a>&nbsp; &nbsp; Operators and Operands</a>
                   </li>
                   <li>
                    <a>&nbsp; &nbsp; Functions</a>
                   </li>
                   <li>
                    <a>&nbsp; &nbsp; Main Function </a>
                   </li>
                   <li>
                    <a>&nbsp; &nbsp; Error Types </a>
                   </li>
                   <li>
                    <a>&nbsp; &nbsp; <del>Turtle Graphics</del></a>
                   </li>
                   <li>
                    <a>&nbsp; &nbsp; Modules</a>
                   </li>
                   <li>
                    <a>&nbsp; &nbsp; For Loops </a>
                   </li>
                   <li>
                    <a>&nbsp; &nbsp; Selection</a>
                   </li>
                   <li>
                    <a>&nbsp; &nbsp; String Comparison </a>
                   </li>
                   <li>
                    <a>&nbsp; &nbsp; Conditionals </a>
                   </li>
                   <li>
                    <a>&nbsp; &nbsp; Boolean Functions </a>
                   </li>
                   <li>
                    <a>&nbsp; &nbsp; Iteration </a>
                   </li>
                   <li>
                    <a>&nbsp; &nbsp; Nested Iteration </a>
                   </li>
                   <li>
                    <a>&nbsp; &nbsp; Escape Sequences</a>
                   </li>
                   <li>
                    <a>Conceptual Programming Ideas </a>
                   </li>
                   <li>
                    <a>&nbsp; &nbsp; Function Decomposition </a>
                   </li>
                   <li>
                    <a>&nbsp; &nbsp; Function Composition </a>
                   </li>
                   <li>
                    <a>&nbsp; &nbsp; Flow of Execution</a>
                   </li>
                   <li>
                    <a>&nbsp; &nbsp; How to Lay Out a Python Program</a>
                   </li>
                   <li>
                    <a>Keywords and Functions to Use While Coding</a>
                   </li>
                </ul>
            </div>
        </nav>
        <main>
            <h1>Programming Tips</h1>
            <p>
                This textbook has a chapter full of tips to help produce good code and help you stay happy during that 
                process. Very important and useful info. Here is a link: 
                <a href="https://runestone.academy/ns/books/published/thinkcspy/Debugging/toctree.html">Ch 3</a>.
            </p>
            <p>
                Make sure to fully understand what you want to do first. Many professors recommend writing out the steps 
                that you will take in your program first, either in plain writing or in pseudocode (if p == 1 add 
                2 is psuedocode, because it says what you want to do but isn't fully accurate code).
            </p>
            <p>
                Start with something small and make sure it works before moving on to the next part. Once you get 
                something that works, you can continue adding to it. It is easier to do this than to try to do 
                everything at once and go back and check it later. This also "creates a lot of small victories for 
                yourself" which helps keep the whole process from being evil and draining and boring. 
            </p>
            <p>
                It is important to test as you go. This helps you verify that your code is working and eliminate edge 
                cases that may arise unexpectedly. 
            </p>


            <h1>Background</h1>
            <p>
                Python is a high-level programming language. Low-level programming languages 
                are also called machine languages or assembly languages, and they are the  
                information passed directly to the computer to instruct it. High-level languages 
                are ways of coding that the computer must process before it can understand and 
                execute. It is easier to write in high-level languages. Additionally, high-level 
                language code is 'portable' in that it can be processed and run on/by multiple 
                types of computer, while low-level languages are specific to one kind of computer.
            </p>
            <p>
                There are two kinds of programs to process high-level languages. Interpreters read 
                the code and execute it by alternating between reading lines of code and performing 
                computations. Compilers read the program completely before starting to run the code. 
                It takes in source code (the high-level language code) and converts it to object 
                code/the executable (low-level language translation of source code). Once code is 
                compiled, it can be run repeatedly. In contrast, interpreters have the same process 
                of reading and running every time, regardless of whether they have seen the code 
                before. Many modern languages use both processes. First, a compiler converts source 
                code into byte code, which is interpreted by a virtual machine. Python does this, 
                but is more broadly considered an interpreted language.
            </p>
            <p>
                Shell mode is a way of using the Python interpreter where you type Python expressions 
                into the Python shell, which spits out a result. This is helpful for testing small bits 
                of code where you want immediate feedback. Program mode is when you instead write a 
                program in a file (the source code) and pass it to the interpreter. 
            </p>
            <h3>.py</h3>
            <p>
                When in program mode, end the name of your source code with .py to tell the intepreter 
                that it is a Python program. Run this program by calling python filename.py in the 
                command line.
            </p>
            <h3>Formal and Natural Language</h3>
            <p>
                Natural language is spoken language that evolved naturally. Formal languages are developed 
                specifically and intentionally with a specific purpose or application in mind. Mathematics, 
                chemistry, and programming all use formal languages to standardize syntax and make work 
                legible to other people. Formal languages therefore have strict syntax rules in a way that 
                natural language does not. If you say "hillo", English speakers will most likely gather that 
                you wanted to convey a greeting, but if you say "5 s 2", mathematicians will be unlikely to 
                understand that you wanted to subtract 2 from 5.
            </p>
            <p>
                Tokens are the basic elements of a language, such as words, numbers, or chemical elements. 
                Structure is the way that the tokens are arranged. It is especially important in a formal 
                language to ensure that you are using the correct tokens and structure.
            </p>
            <p>
                Parsing is the process of figuring out what a language expression means, such as reading a 
                sentence and interpreting that this word is a verb and that one a subject and so on. Once 
                you have parsed a sentence, you can figure out what the sentence means, which is its 
                semantics.
            </p>
            <p>
                There are other differences between natural and formal languages. Formal languages are 
                intentionally unambiguous (for the most part...) so that every statement has one 
                interpretation which does not rely on context. Formal languages also aim for less 
                redundancy and for brevity. Finally, formal languages are very literal and lack idiom 
                and metaphor. Formal languages are often dense, for all the reasons given above.
            </p>


            <h1>How to Actually Code!</h1>
            <h3>Basic Computations</h3>
            <p>
                A program tells a computer how to perform some action. Here are the basic intructions 
                you will see and use:
            </p>
            <ul>
                <li>input: get data from somewhere</li>
                <li>output: display data to somewhere</li>
                <li>math: perform basic mathematical operations</li>
                <li>logic: perform basic logic operations (and/or/not/etc)</li>
                <li>conditionals: perform some action based on a certain condition</li>
                <li>repetition: perform an action some number of times</li>
            </ul>
            <h3>Bugs and Errors</h3>
            <p>
                Programming errors are called bugs, and debugging is just the process of finding and 
                correcting them. There are three kinds of errors: 
            </p>
            <ol>
                <li>Syntax errors: an error in formatting that the compiler/interpeter cannot read/process.</li>
                <li>
                    Runtime errors: an error that has correct syntax but produces an invalid result. 
                    These only appear when you run the program, because the interpeter/compiler can read 
                    the code without detecting issues. They are also called exceptions.
                </li>
                <li>
                    Semantic errors: an error in which the program runs successfully but produces a 
                    different result than you wanted it to.
                </li>
            </ol>
            <h3>Comments</h3>
            <p>
                Comments are a great way to make your code more legible/understandable. They are little 
                bits of text that the intepreter/compiler ignores. Some examples of when it is helpful to 
                include a comment are: to explain how a confusing part of code works, to explain what a 
                program or specific method does when you know you will need to look back at something later, 
                to suggest parts of your code to check for errors, to keep old code that you don't want run 
                but may want to look back at, to explain to an instructor why you did things a certain way.
            </p>
            <p>
                Blank lines between code are also ignored by the interpreter/compiler but can make your code 
                a lot neater and more legible, so it is good programming practice to use them liberally.
            </p>
            <h3>Variables &lt;3</h3>
            <p>
                A variable is a name that refers to a particular value. Assignment statements create variables 
                and assign them a value. It is very easy to create and assign a variable in Python. You just 
                give a variable a name (like var1) and assign it to a value (like 3) using the assignment 
                operator, which is just an equal sign. So it would just look like var1 = 3 and then my var1 
                variable is created, assigned, and ready to use!
            </p>
            <p>
                Variables often change, so you can reassign them in your code. The value of a variable is 
                whatever it was most recently assigned. To reassign a variable, use the exact same process that 
                was used to create it in the first place.
            </p>
            <p>
                Another thing to mention about assignment and reassignment is that you can set a variable equal 
                to another variable. This just means that the first variable takes on the value of the second 
                variable at the time of assignment, although one or both can change value later without affecting 
                the other. This actually is not true for other languages, such as Java! Python is much easier to 
                use when it comes to changing the values of variables.
            </p>
            <p>
                The most common reason a variable would be reassigned is that it is some sort of counter that 
                needs to update a total. Sometimes you will see x = x + 1, which is an expression that gets the 
                value of x and then sets the new value of x equal to the old value of x plus one. This works 
                because the interpeter/compiler first evaluates the expression on the right side of the 
                assignment operator, then sets the variable equal to that result. For this reason, this only works  
                with an existing variable. You cannot have this be the statement that creates the variable and 
                assigns it. The process of setting a variable equal to itself + 1 is called incrementing, and the 
                process of setting a variable equal to itself - 1 is called decrementing.
            </p>
            <p>
                There are a lot of rules and conventions when it comes to naming variables. You cannot use a 
                space in a variable name. It is common to use underscores in place of spaces in long variable 
                names, such as price_of_item. You should start a variable name with a letter, not an underscore 
                or number, though it is common and accepted to use numbers in a variable name. Capitalization 
                matters, so cat and Cat are different variables. You also cannot use 'reserved characters' as a 
                variable name. Reserved characters are things like +, -, =, or keywords that refer to functions 
                (eg type or print). You can use those words within the variable name if you really want to, such 
                as var_type or str_to_print. Python programmers typically prefer to use lowercase letter in 
                variable names, especially for the first letter.
            </p>
            <h3>Data Types!</h3>
            <p>
                A value/object is something such as a word or number that a program can use or manipulate. 
                There are different data types that a value can fall under.
            </p>
            <p>
                A string is a data type that usually contains a word or phrase, although numbers can be part 
                of a string. A string is enclosed in quotation marks; either " " or ' ' work. When you use " ", 
                you can include ' ' as a character within your string, such as "Joy's cat" or "said 'meow'". 
                The reverse is also true; strings denoted by ' ' can contain " " as a character. You can also 
                use ''' ''' or """ """ if you want to include both ' ' and " " in your string. This is called 
                a triple quoted string. A string is referred to as str in Python. Strings are also immutable, 
                which means you cannot change a string without completeely reassigning it. You can reassign 
                the variable with some opertion done on the original string, though.
            </p>
            <p>
                An integer is a whole number. It is referred to as int in Python. A floating point number is a 
                number with a decimal point. It is referred to as float in Python. Do not put commas or spaces
                in either of these, because that can change the way the compiler/interpreter reads the value.
            </p>
            <p>You can find out the data type of a value by using the type() function. It will not display to 
                the screen automatically, because sometimes you want to use that funtion within a conditional 
                or something, so if you want it to print to the screen, use the print function like this: 
                print(type(__)) with your value where the underline is.
            </p>
            <p>
                You can also convert a value from one data type to another. Python is especially efficient at 
                this! It has built-in functions such as int(), float(), and str() to do this. These are type 
                conversion functions. There are, however, some rules about how to use them. For example, int() 
                can take a float or str and convert it to an int by discarding anything after any existing 
                decimal points. float() can take an int, and will add a .0 to the end of it. float() can also 
                take a string if the string has no tokens that would be invalid in a float. str() just sticks 
                quotes around whatever you give it to convert something into a string.
            </p>
            <p>
                Some data types, including floats and ints, are considered primitive data types, because they 
                cannot be broken down into smaller parts. Strings and lists (we have not talked about lists 
                yet) are two data types that can be broken down into smaller pieces, also called collection 
                data types. Strings are typically letters and characters, and can be broken into smaller 
                strings. You can access parts of a string by indexing it. This means that each character is 
                assigned a number corresponding to its place. From left to right, the numbers start at 0 and 
                count up. From right to left, the numbers start at -1 and count down. So string[0] gives you 
                "s", string[5] gives you "g", and string[-2] gives you "n". Spaces are included as characters.
            </p>
            <h3>More on Strings</h3>
            <p>
                You can also do string slicing, which is simply getting a substring of more than one character. 
                You do this by using a colon : in the brackets. The resulting slice will start at the first 
                index provided but will only go up to the second without including it! Using the same string 
                from above, string[0:5] gives you "strin" and using string[1:3] gives you "tr". You can also 
                leave the second number off and just do string[0:] which will give you everything after the 
                selected index. In this case, you would get "string". In the case of string[2:], you would 
                get "ring". Similarly, you can leave the first number off to get everything up to the 
                specified index (noninclusive). For example, string[:3] will give you "str".
            </p>
            <p>
                There are also some specific string constants. These can be useful if you are looking to 
                compare strings or find out some information about what a string contains. As you will see in 
                the image below, you must import the string module to use these. Here is a list of the string
                constants:
            </p>
            <img src="images/string_constants.png" alt="a list of the string constants and what they return">
            <h3>Lists</h3>
            <p>
                Lists are another data type that have a lot of special properties and abilities, which is why 
                they're getting their own little section.
            </p>
            <p>
                A list is a collection of other values, organized in order with index numbers. The values are 
                each called elements and can be of any data type. You can even have a list of smaller lists! 
                In Python specifically, you can also have a list with multiple different data types. 
            </p>
            <p>
                To create a new list, use square brackets and any data you want to use to fill in your list - 
                so far; you can add to a list very easily! For example, emptyList = [] and filledList = ["a", 
                "b", "c", 1, [2, 3]]. You can use the len() method to find out how many elements are in a list. 
                This method also works for finding out how many characters are in a string. The information 
                will not be printed to the screen automatically, but if you were to say print(len(filledList)), 
                the number 5 would print to the screen. This list has three string elements, one integer element, 
                and one list element or sublist. Accessing elements in a list works the same way that accessing 
                characters within a string does. As a note, you can use indexing to access elements within a 
                sublist or characters within a list like this: filledList[0][0] gives you the character "c" and 
                filledList[4][1] gives you the integer 3.
            </p>
            <p>
                You can add elements to a list by treating the list like a string. Using the filledList from 
                above, we can add the string "hello" to it by doing filledList = filledList + ["hello"]. 
                This is like string concatenation. Whatever you add to the list will be added onto the end. 
                If you use the multiplication operator, you can also repeat items in the list. If you have a 
                newList = [2, 3, 4] and you do print(newList * 2), then [2, 3, 4, 2, 3, 4] will be printed to the  
                screen. You can also do slicing like you can with strings. newList[1:] will give you [3, 4] and 
                newList[:2] will give you [2, 3] and newList[1:2] will give you [3]. Lists are different from 
                strings in that they are mutable. With strings, you would have to create a new variable or reassign 
                the existing string variable to make these changes. With lists, you can change them as they are, 
                because they are designed to change and shrink and grow &lt;3. This means that if you want to change 
                a particular element in a list, you can just select the item via indexing or slicing and reassign it!  
                For example, newList[1:2] = 5 will result in newList = [2, 5, 4] and newList[2] = "hi" will result in 
                newList = [2, 5, "hi"]. We could even take one of the elements and set them equal to an empty list to 
                remove it! newList[0] = [] gives us newList = [5, "hi"]! Something I just learned and did not know is 
                that you can actually use slicing to insert an element into a list at a spot that is not the end! 
                Since newList[1:1] is not a valid slice (it is telling the computer to start at 1 and go until it 
                reaches 1 but don't include 1), this is a way of adding an element to a list by choosing that spot. 
                newList[1:1] = [3, 4] will give us [5, 3, 4, "hi"].
            </p>
            <p>
                Although you can delete elements from a list by setting it equal to an empty list, there are also 
                functions you can use with lists to do this. del newList[2] is an easy way to do this, as del is the 
                name of the delete function. Other list functions include append() which adds an element, pop() which 
                removes the last item and returns it (ie if you assign a variable to newList.pop() it will set the 
                variable equal to "hi" and newList = [5, 3, 4]). There is also remove() in which you put a value in 
                the parenthesis and it will take the first occurance of that value out of the list. Similarly, index() 
                takes a parameter in the parenthesis and returns the index of the first occurance of that value. count() 
                does something similar, returning the number of times that the value provided appears in the list. There 
                is also sort() which sorts a list and reverse() which reverses the order of a list. Finally, there is 
                the function insert(), which takes two parameters. The first parameter is a position in the list, and 
                the second is a value that you want to add to that list in that position. 
            </p>
            <p>
                List cloning is when you make a new list and fill it with the same elements as the old list. If you 
                simply set a list equal to another list (a = [2, 3] and b = a), you are actually creating two 
                variables that point to the same data. This means that if you change a, b also experiences those 
                changes and vice versa. Instead, use slicing to clone it by saying a = [2, 3] and b = a[:]. There is 
                also a function for this called copy().
            </p>
            <h3>List Comprehensions</h3>
            <p>
                I despised list comprehensions, they were very hard to learn. Kind of cool once you get the hang of it, 
                though. I hope that this explanation is helpful if you choose to read this section.
            </p>
            <p>
                List comprehensions are a way of creating and filling a list systematically according to a formula, all 
                in one line. This means you create your list, and in the parenthesis you put an expression, followed by 
                "for _ in _". This part makes it so that a definite number of elements is added to the list, and it 
                does not just keep repeatign forever. Here is an example from the textbook:
            </p>
            <img src="images/list_comprehension.png" alt="an example of list comprehension">
            <p>
                In this case, they are using the size of mylist. But more than that, they are using each element in mylist 
                itself, taking the value and squaring it before adding it to yourlist. The item ** 2 ie squaring is the 
                expression, the "for item" is the "for _", and the "in mylist" is the "in _". This whole thing is saying 
                that yourlist is made by looking at each element in mylist and squaring it.
            </p>
            <p>
                Not to further complicate things, but you can also add a condition to the end of this whole situation. For 
                example, if we wanted to make sure that we were only squaring the even numbers in mylist, we could say 
                <span class="psuedo">yourlist = [item ** 2 for item in mylist if item % 2 == 0]</span>
            </p>
            <h3>Tuples</h3>
            <p>
                A tuple is like a list but immutable. You can index and slice a tuple but you cannot change elements the 
                same way you cannot change letters in a string without reassigning it or something. A tuple is typically 
                represented with parenthesis instead of square brackets, like this tuple = ("hi", "hello", "welcome"). I 
                don't really like tuples because I feel like they are just less helpful lists, but Python people love 
                tuple assingment and tuple unpacking. I don't feel like getting into it because I don't really get those 
                things, but maybe one day I will come back to this section and update it... here's a link to a page on 
                tuple assignment if that happens or if you want to read about it! 
                <a href="https://runestone.academy/ns/books/published/thinkcspy/Lists/TupleAssignment.html">link</a>
            </p>
            <p>
                The one good thing I have to say about tuples is that a function can return a tuple. Sometimes you want 
                a function to return more than one thing, and using a tuple is the only way to do that.
            </p>
            <h3>Dictionaries</h3>
            <p>
                Dictionaries are a different kind of data collection. In lists and tuples and so on, data is stored 
                kind of sequentially. In a dictionary, data is mapped to a location based on its value. A dictionary uses 
                curly braces {} the qay a list uses square brackets []. It has values like other data collections, but has 
                keys instead of index values. Instead of using numerical index values, keys are unordered and correspond 
                to a specific meaning. A good example from the textbook is using a dictionary to store Spanish words and 
                their English translations. Your keys would be "rojo", "gato", and "hola" while the values would be "red", 
                "cat", and "hello". Instead of doing exampleDictionary[0], you would get a specific element by doing 
                exampleDictionary["gato"], which would give you the value "cat".
            </p>
            <p>
                You can create a dictionary by setting the dictionary name = {} to create an empty dicitonary which you can 
                later add values to. You can also create a dictionary by putting the values directly into the brackets during 
                initialization like this: exampleDictionary = {"gato": "cat", "rojo": "red", "hola": "hello"}. The left hand 
                side must be the key and the right hand side must be the value, and the colon : specifies that this specific 
                key is associated with this specific value. These key-value pairs are actually stored unpredicatably, so they 
                are not stored chronologically or lexically or anything. There is some algorithm to figure out how they're 
                stored, but it doesn't really matter too much.
            </p>
            <p>
                You can use the del keyword on a dictionary to delete values, such as del exampleDictionary["gato"]. 
                You can also reassign values, such as exampleDictionary["hola"] = "hi". Using the len keyword on a dictionary 
                will return the number of key-value pairs in the dictionary. There are some other functions that you can use 
                with dictionaries:
            </p>
            <dl>
                <dt>keys()</dt>
                <dd>
                    This function returns something called a 'view' of the keys in the dictionary, which looks like this: 
                    dict_keys(['apples', 'bananas', 'oranges', 'pears']). You can use the function list() to convert this to a 
                    normal list.
                </dd>
                <dt>values()</dt>
                <dd>
                    This function returns something called a 'view' of the values in the dictionary, which looks like this: 
                    dict_values(['apples', 'bananas', 'oranges', 'pears']). You can use the function list() to convert this to a 
                    normal list.
                </dd>
                <dt>items()</dt>
                <dd>
                    This function returns something called a 'view' of the key-value pairs in the dictionary, which looks like: 
                    dict_key_vals(['apples', 'bananas', 'oranges', 'pears']). You can use the function list() to convert this to a 
                    normal list.
                </dd>
                <dt>get()</dt>
                <dd>
                    This function takes a key as a parameter and returns the value at that key.
                </dd>
            </dl>
            <h3>Using Files</h3>
            <p>
                Most of the time (particularly for a marine bio/oceanography student using Python, I presume), your data 
                will come files! So here is how to access that data!
            </p>
            <p>
                To open a file, you will want to use the open() function. There are two ways of doing this. open() takes 
                two parameters. The first is a filename, and the second is either "r" or "w". If you use "r", this tells 
                the computer that you are opening a file with data already in it which you wish to read. If you use "w", 
                this tells the computer to open an empty file and add data to it. "r" stands for read, and "w" for write. 
                When you are adding data to an empty file, you are writing to a file. When you use the open() function, 
                you are creating a reference to this file, so you will usually end up wanting to use a variable to store 
                the file name instead of using the filename itself in that parameter. This also helps because you will 
                need to close the file at the end of your program, which you do by referencing the variable that holds 
                the file name and doing filevariable.close()
            </p>
            <p>
                If a file is in the same folder/directory as your current program file, you can just use the program file. 
                Otherwise, the easiest thing to do is probably to copy the file path of a file, which you can do by 
                right-clicking on the file in your file app and selecting copy path.
            </p>
            <p>
                There are a few ways to read a file. You can use a for loop where you look at each line. Basically, your
                file is just a very long string separated by newline characters, so you can iterate through each line in
                the file with something like <span class="psuedo">for line in filevariable:</span> and your computer will 
                go through each line. If there are columns of data, you can use the split() function to split them into a 
                list of values, which you can then index to get the one you need. The split() function takes a string and 
                splits it into a list. If you do not add a parameter to specify how to split it, it splits automatically at 
                a space between data. However, you can add a specific string to the parenthesis to clarify how you want the 
                data split. For example, you could split the string a = "hello people" at each "l", leaving you with the  
                list ["he", "o peop", "e"]. Note that whatever character(s) you split on will not be included in the list.  
                If you do a.split(""), it will split every individual character like this: ["h", "e", "l", "l", "o", etc]. 
            </p>
            <p>
                Another way to read a file is by using the built in file functions. Python has three methods you can use 
                for file reading: read(), readline(), and readlines(). read() goes through the entire file at once, which 
                is not that helpful if you need data from each line but could be useful if you wanted to know, for example, 
                how many lines are in the file (count newlines). readline() reads only the next line, keeping it as a string. 
                readlines() reads the entire file but keeps each line as a separate element in a list of strings. A lot of 
                the time, I use a while loop with readline() so that I can get each line one at a time and do something with 
                the data I need each time. In something ilke this, I usually have a variable that I use to hold the whole 
                line which is updated every time the loop runs.
            </p>
            <p>
                Writing to a file is much simpler. There is one function to write to a file, and it is write(). This function 
                takes a string as a parameter, which is the string that you want to add to the file.
            </p>
            <h3>Statements vs Expressions</h3>
            <p>
                A statement is an insruction that an interpeter/compiler can execute, such as an assignment 
                statement. An expression is a combination of values, variables, operators, and functions that 
                a compiler/interpreter evaluates. If you print an expression, it will just print the result.
            </p>
            <h3>Operators and Operands</h3>
            <p>
                Operators are special tokens that have a specific purpose such as addition or assignment. The 
                values that they affect are called operands. Operands can be variables. Operators differ by 
                language, so the ones below are specific to Python in both what token they are represented by 
                and what they actually do.
            </p>
            <dl>
                <dt>+</dt>
                <dd>
                    Adds two values together if valid values are provided. Number + number = number and str + 
                    str = concatenated str (eg "two" + "three" results in "twothree").
                </dd>
                <dt>-</dt>
                <dd>Subtracts two numerical values if valid values are provided. Does not work for strings.</dd>
                <dt>*</dt>
                <dd>
                    Multiplies two values if appropriate values are provided. You can also multiply a string 
                    by an integer to concatenate the string to itself several times (eg "hi" * 3 results in "hihihi").
                </dd>
                <dt>**</dt>
                <dd>Exponentiation operator. The first value is multiplied by itself the number of times given by the 
                    second number (eg 2 ** 3 results in 8).
                </dd>
                <dt>/</dt>
                <dd>
                    Divides the first value by the second if appropriate values are provided. It always returns a 
                    floating point number as a result.
                </dd>
                <dt>//</dt>
                <dd>
                    This is called integer division, and it is used when you want to truncate the result and get an 
                    integer result. Note: it always rounds down to the lowest number, so when your result is negative, 
                    it is going to return the more negative number (eg 6//4 results in 1 but -6//4 results in -2 
                    because -6 divided by 4 is -1.5).
                </dd>
                <dt>%</dt>
                <dd>
                    This is the modulus operator, also sometimes called the remainder operator. It divides the first 
                    operand by the second and results in the remainder.
                </dd>
            </dl>
            <p>
                You can use multiple operators in an expression, and they will be evaluated following the rules of 
                precedence. This is generally the same as the mathematical rules of precedence (ie PEMDAS). Note: in 
                the rules of precedence, operators with equal precedence are left-associative ie go from left to 
                right. The exception to this is exponentials, which go from right to left. For example, 2 ** 3 ** 2 
                is 512 instead of 64 because instead of doing (2 ** 3) ** 2 and getting 8 squared, it does 2 ** (3 
                ** 2) and gets 2 to the ninth. In addition to using parenthesis to change the order of operation, 
                you can also use parenthesis extraneously just to make the expression easier to read. 
            </p>
            <h3>Functions</h3>
            <p>
                A function is a sequence of statements grouped together under a name that a program can call to execute 
                the statements at any time. They are used to organize programs and increase functionality. To create a 
                function, you use the "def" keyword followed by a name and parenthesis, in which you can add parameters 
                if you want to. All of this is followed by a colon and then your code to execute (indented from the line 
                above and lines below the function). This looks like:
            </p>
            <p class="psuedo">def name(parameter, parameter):<br>&nbsp; &nbsp; &nbsp; statements</p><br>
            <p>
                The naming rules and conventions for functions in Python are, as far as I know, the same as the ones for 
                variables. Also, the parameters of a function are basically variables specific to the function. So 
                whatever parameters you use will be visible within the function but will not be declared in the typical 
                sense. When you call a function that has parameters, you call it by using the name of the function with 
                values to assign to the parameters in parenthesis, such as name(3, "for")
            </p>
            <p>
                You can also define variables within the function. Due to rules about variable accessibility, variables 
                created within the function will also not be accessible outside of the function (just like parameters). 
                Generally, in my limited experience, you do this when you only need the variable temporarily within the 
                function and don't want or need it to be seen outside the function. The benefit to defining parameters 
                is that you can pass them into the function with different values that change the functionality of the 
                function. 
            </p>
            <p>
                So as an example, if you have a function that returns a sum after it adds two to itself a 
                certain number of times, you might want to use a parameter to pass in the number of times you want it to 
                be added as well as a variable that starts at 2 and is updated until the function has executed the 
                appropriate amount of additions. That way, when you call the function, you can tell it how many times to 
                add two, but don't have to also provide the same variable of 0 every time. 
            </p>
            <p>
                It is also customary to include a docstring in your function. A docstring is just a special kind of comment 
                that exists mostly to describe what a function does. It has some special properties such as theoretically 
                being retrieved at runtime but I don't really know anything about that so. moving on.
            </p>
            <p>
                When you write a function, you may want it to just execute some steps such as opening a window or creating 
                an object. However, there are also a lot of times where you will want it to manipulate some value that you 
                will use again later in the code. This is when you would want to return that value. Returning something 
                means that when you call a function, it produces a value that you can store in a variable or feed as a 
                parameter into another function or something. You do this by putting the keyword "return" at the bottom of 
                your function, followed by a space and then a value. Usually this will be a variable, it is unlikely that 
                you would ever see something like "return 5". 
            </p>
            <p>
                A local variable is one that only exists within a subset of code such as a function, while a global variable is 
                one that exists within every part of the code that comes after the definition of the variable. The "lifetime" of 
                a local variable is the amount of time that it is valid/able to be used. If you use a local variable outside of 
                its lifetime (ie outside of a function it is created inside of), you will get an error message. Since the 
                lifetime of a global variable is the entire document, you can call a global variable within a function. However, 
                this is considered a bad coding practice, and should be avoided. If you want to access a global variable in your 
                function, the best way to go about doing that is to make a parameter and pass the variable into the function that way.
            </p>
            <h3>Main Function</h3>
            <p>
                Many languages don't allow you to just have code sitting at the bottom of your program to call things. Python doesn't rally care, 
                so you don't <em>have</em> to worry about a main function (more alliteratively known as the main method), but it is considered a 
                good coding practice to use one anyway. The main method just holds all the code that you need to actually run your program in one 
                function, and allows you to just call that at the bottom of your program. It's mostly just a way of organizing things, at least in 
                a Python document.
            </p>
            <p>
                Another reason to have a main method pertains to modules. Before an interpeter runs your program, it gets information on the program. 
                One piece of information that it collects is a variable called __name__, which defaults to the string value "__main__" when it finds 
                that the program is being run on itself. If the program is being imported by another program, then __name__ is set to the filename 
                of that module. This is used to determine when to execute or not execute the main method. If you are writing a program with the 
                intention of exporting it to another program, you may want to call your main method in a conditional instead of just calling it every 
                time your program runs. Your condition would be if __name__ == "__main__": and then it would call the main method.
            </p>
            <h3>Error Types</h3>
            <p>
                Nearly 90% of the errors that the authors of the textbook encountered while writing it were one of four 
                error types. Here are those errors and what they mean.
            </p>
            <ul>
                <li>ParseError: a syntax error which prevents the compiler/interpreter from parsing your code</li>
                <li>TypeError: an error that occurs when incompatible data types are provided and cannot be used</li>
                <li>
                    NameError: an error that arises when a variable name cannot be found for one reason or another. Often 
                    this comes from trying to use a variable before it has been assigned a value, or misspelling a variable 
                    you want to reference.
                </li>
                <li>
                    ValueError: when the value passed to a function is not compatible. For example, when you try to convert 
                    user input into an integer but the user did not type anything. This is different from a TypeError, which 
                    would be more like trying to convert the string "hi" into an integer.
                </li>
            </ul>
            <h3>Turtle Graphics</h3>
            <p>
                The next chapter is about how to use turtle graphics, which is a fun and cool thing you can do in Python that 
                allows you to create a little object on the screen called a turtle that you can move around and manipulate. I'm 
                going to leave this section blank for now and come back to it if need be, but here is a link to that part of the 
                book: <a href="https://runestone.academy/ns/books/published/thinkcspy/PythonTurtle/toctree.html">Ch 4</a>
            </p>
            <h3>Modules</h3>
            <p>
                A module is a file containing Python definitions and functions that you can use in your program. You import them 
                separately in order to use their functions and etc. You can find Python modules by looking at the Python 
                documentation <a href="http://docs.python.org/py3k/">here</a>. The documentation also has a lot of other useful 
                information and is worth checking out, I guess. When using something from a module, you use dot notation to tell 
                the interpeter/compiler that you are referencing the module. This is just using the name of the module, a dot, 
                and then the thing you're using. So to use the square root function in the math module, it would be math.sqrt()
            </p>
            <p>
                Other helpful modules include the math and random modules, which you can use to do more complex math and to pick 
                random values respectively.
            </p>
            <p>
                Any source code that you write is technically a module, so you can import your own code and use your own methods 
                in other work by just saying "import filename" and omitting the .py
            </p>
            <h3>For Loops</h3>
            <p>
                A for loop is a valuable tool in programming that tells a program to execute specific steps a certain number of 
                times until some condition is met. I think the easiest way to show this is by going through an example. 
            </p>
            <p>
                Think about multiplication. multiplication is the process of adding a number to itself a certain number of times, 
                eg 2 times 5 is equal to 2 + 2 + 2 + 2 + 2. So if we put this into a for loop, we would say for every time until we 
                reach the sixth time, add two to a sum variable. In order to perform that checking operation that stops the loop 
                from adding the 2 a sixth time, we can use the range function. This function returns a sequence of numbers between 
                0 and a specified number. So by using the range function, we are saying that the program should add 2 to a sum 
                variable for each time within the returned sequence of numbers given by range(). Here's the code:
            </p>
            <p class="psuedo">
                def multiply(num, by):<br>
                &nbsp; &nbsp; &nbsp; total = 0<br>
                &nbsp; &nbsp; &nbsp; for n in range(by):<br>
                &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; total = total + num<br>
                &nbsp; &nbsp; &nbsp; return total<br>
            </p>
            <p>
                So what this is doing is taking the expression 2 * 5, where 2 is the "num" number and it is multiplied "by" 5. Then, it 
                is starting a sum variable called total at 0 so that the existing sum is 0. Then, it has a for loop that uses range 
                to stop the for loop on the "by"th (5th) repetition. It does this by calling range(by) to get the sequence of numbers 
                between 0 and "by", which is 0, 1, 2, 3, 4 because range starts at 0 and stops "at" the number provided, not "on" it. 
                It is using a counter variable n to refer to each number in that list. So on the first run-through, n = 0. The total 
                is increased by our "num" number, which is 2. It has reached the end of the indented text, so it automatically 
                moves n forward by setting it to the next number in the sequence. So now n = 1. The process repeats, so 2 is added to 
                the total. Then n = 3, and 2 is added again. Then n = 4, and 2 is added again. Then n = 5, which is not in the 
                sequence, so the for loop sees that and stops performing actions. The next line of code after the for loop activates, 
                which is the return statement in this case. Since we've added 2 to the total variable on each of the five times the loop 
                ran, we should be returning a total of 10.
            </p>
            <p>
                Also, it is very, very common to use i as the counter variable instead of n like in the example. Like nearly every time, 
                you will see i, especially in Java. I think it is fine to use something that is not i especially because you could use 
                something more descriptive and clear, but just know that most of the for loops you see will use i.
            </p>
            
            <h3>Selection</h3>
            <p>
                A bool is another data type used to store either of two values: True and False. These are different from strings and are 
                not contained by quotes. You can use an expression with logic operators to get a bool in Python, such as print("hel" + "lo"
                 == "hello") which will print the bool True to the screen.
            </p>
            <p>
                There are seven comparison operators that return a boolean value by comparing two values:
            </p>
            <dl>
                <dt>==</dt>
                <dd>Equality operator; checks whether two values are equivalent</dd>
                <dt>!=</dt>
                <dd>Checks whether two values are <em>in</em>equivalent</dd>
                <dt>&lt;</dt>
                <dd>Checks whether first value is less than second value</dd>
                <dt>&gt;</dt>
                <dd>Checks whether first value is greater than second value</dd>
                <dt>&lt;=</dt>
                <dd>Checks whether first value is less than or equal to second value</dd>
                <dt>&gt;=</dt>
                <dd>Checks whether first value is greater than or equal to second value</dd>
            </dl>
            <p>There are three logical operators which also return bools</p>
            <dl>
                <dt>and</dt>
                <dd>Only returns True if both expressions return True</dd>
                <dt>or</dt>
                <dd>Returns True if one of the expressions returns True</dd>
                <dt>not</dt>
                <dd>Only returns True if the expression returns False</dd>
            </dl>
            <p>
                Something that could be important is that there is a hierarchy of operators. 
                First come the mathematical operators, with their own precedence still in place. 
                Then, the comparison operators. Finally, the logical operators. There is also a 
                hierarchy within the logical operators themselves, with "not" coming before "and" and 
                "and" coming before "or".
            </p>
            <p>
                There is also another operator used with lists and strings, which is the "in" operator. This operator 
                checks if certain characters are in a string. For example, you can use the string "apple" and do either 
                print("p" in "apple") which will print True, or print("pa" in "apple") which will print False, because 
                those characters don't appear in that order in that string. This operator is also often used with the 
                not operator to ask if a character is <em>not</em> in a string/an element in a list.
            </p>
            <h3>String Comparison</h3>
            <p>
                You can use the equivalence operator == to check if two strings are the same. You can also use some other
                comparison operators (&lt; and &gt;) to compare the lexicographical order of two strings, ie which comes 
                alphabetically first (although all capital letters come before all lowercase letters lexicographically). 
                This is because the computer gives an ordinal number to all characters, which you can see by using the ord() 
                function. When you use comparison operators to compare two strings, the computer translates the strings 
                into their ordinal numbers and checks to see which is smaller ie first ordinally. :&rpar;
            </p>
            <h3>Conditionals</h3>
            <span>
                <p>
                    A selection statement, conditional statement, or conditional is a way of making sure a portion of your code only runs if 
                    certain conditions are true. The simplest form of selection statement is the if statement. An if statement looks like this:
                </p>
                <img src="images/if_statement.png" alt="if statement psuedocode" style="text-align: center;">
            </span>
            <br>
            <p>
                The boolean expression is called the condition. The if statement is fairly straightforward. If the condition is true, do 
                this action. If it is not true, (else) do this other action. You do not need to include the else statement if you don't 
                want to. In the case where an else statement is omitted, the code block under the if statement will run if the condition 
                is met, and the compiler/interpreter will instead proceed to the text after the if statement if the condition is not met.
            </p>
            <p>
                If you have more than one condition you want to check, there are a couple ways you can go about doing that. You can use 
                a nested if statement, a compound condition, or an elif statement.
            </p>
            <p>
                If you wanted to check that one condition was true first, and then check another condition once you knew it was true, you 
                could use nested if statements. For example, if you wanted to find out if an animal was a lap dog, you could first check 
                if the animal is a dog using an if-else statement. If the animal is a dog, you can then check its size with another if 
                statement nested inside the "if" code block of the first if statement. This nested if statement would check the size of 
                the dog, which would tell you whether the dog is a lap dog. Here's an example:
            </p>
            <img src="images/nested_if_statement.png" alt="if statement with a secondary if statement nested in the else statement" style="text-align: center;">
            <p>
                If you wanted to check if one condition is true in combination with another condition, you could use a compound condition. 
                You would use an if-else statement but change the condition in the if statement to use logical operators. Using the same 
                lap dog example, we would change the if statement so that it checks the type of animal <em>and</em> the size of the animal. 
                Here's what that would look like:
            </p>
            <img src="images/compound_condition_if_statement.png" alt="if statement with a compound condition using the and operator" style="text-align: center;">
            <p>
                Finally, you can use an elif statement when you have multiple conditions that you want to check separately. Elif means "else 
                if". When you use an elif statement, your if statement checks the condition. If the condition is not true, it proceeds to the 
                elif statement and checks if that is true. This means that there are two separate checks. In our lap dog example, this is
                actually kind of the least efficient way to do this just because we will have to use the compound condition if statement and
                so may as well have just done that by itself. But here is an example using an elif statement:
            </p>
            <img src="images/elif_statement.png" alt="an elif statement" style="text-align: center;">
            <p>
                Another important thing to mention is that you can use multiple elif statements in succession, and the compiler/interpreter 
                will just keep going through them and checking their conditions until it finds one that is true. Relatedly, if you have an 
                elif statement in which multiple conditions are true, the compiler/iterpreter will only execute the code block under the 
                first elif statement in which the condition is true!
            </p>
            <h3>Boolean Functions</h3>
            <p>
                Boolean functions are functions that return True or False. Many boolean functions use conditionals. It is common for boolean 
                functions to have a name that sounds like a question, such as isDivisible or is_even_num. That way, you can call the function 
                on a value and it will either say True or False to the "question".
            </p>
            <h3>Iteration</h3>
            <p>
                Iteration is repeatedly executing the same sequence of statements. A for loop is an example of this, and there are several 
                more. Another way to do iteration is by using a while loop. This is a loop that executes the code block every time until a 
                condition is false. It is common to have a sum variable that you update every time the code block executes, and have the 
                while condition be something like "while sum != 10" or "while sum &lt; 5" so that it stops whent he sum variable reaches a 
                certain number. One thing to note is that the while loop will not stop executing the code block in the middle even if the 
                while condition becomes false in the middle, it will finish executing the entire code block and go back to the top of the 
                loop where it checks whether the condition is true. If the condition is never false, your while loop will continue executing 
                until your device runs out of space and crashes. This is called an infinite loop. A for loop is sometimes considered "definite 
                iteration" because it repeats a specific number of times, and it is harder to get an infinite loop when using a for loop. A 
                while loop can therefore be called indefinite iteration because we don't know how many times it will repeat.
            </p>
            <h3>Nested Iteration</h3>
            <p>
                Nested iteration is a deeply evil and confusing process until you understand it, and then it will be your best friend ever imo. 
                Nested iteration just means having some sort of iteration (usually for loops) nested inside each other. Here is a grid of 
                characters for reference, and then we'll make it:
            </p>
            <p>
                O O O O O<br>O O O O O<br>O O O O O<br>O O O O O<br>O O O O O
            </p>
            <p>
                You can use a normal for loop to print one line of this grid. For example:
            </p>
            <p class="psuedo">
                for i in range(5): <br> &nbsp; &nbsp;print("O ", end="")
            </p>
            <p>
                The end="" just makes it so that when printing, it doesn't automatically add a newline after your printed characters. This way,
                our characters all print on the same line.This will print O O O O O. So what you want to do with your nested for loops is have 
                one for loop that acts exactly like the one above, and prints out one line of the grid. This will be your inner for loop. For 
                the outer for loop, you need to insert a line break after a line of characters is printed. Here's what that looks like: 
            </p>
            <p class="psuedo">
                for i in range(5):<br> &nbsp; &nbsp;for j in range(5):<br> &nbsp; &nbsp; &nbsp; &nbsp;print("O ", end="")<br> &nbsp; &nbsp;print("\n")
            </p>
            <p>
                So what's happening here is that i is initially set to 0 and goes through its code block. First, it finds another for loop. Now 
                j (the counter variable in the second for loop) is also set to 0, and goes through its code block by printing O (and not going 
                to a new line). Then, j is set to 1, and it executes its code block again. This continues until we get O O O O O . The inner for 
                loop always goes through its entire loop every time it is called within an outer for loop! Anyway, now that we have finished one 
                line of our characters, the inner loop is finished. There is more code after the inner for loop to run, so a newline is printed. 
                Now the outer loop continues and i is set to 1. The inner loop is called again, printing another line. Another newline is printed 
                after the inner loop finishes, and this continues on until our whole grid has been printed. 
            </p>
            <p>
                Also, a couple notes. First of all, I used i and j as counter variables here. Traditionally, you will see i as a counter variable 
                for a loop. Since this is a local variable, it is actually still accessible in the inner loop. This means that the outer loop needs 
                its own counter variable, so it is typical to use i, j, and (if you have a third nested loop) k. This also means that you can still 
                use the i and j variables within that nested loop, which is useful if you're trying to do some sort of counting thing where you 
                want to count rows and columns or total characters in the mutliple rows or whatever. Secondly, if you just have an empty print() 
                statement, it will go to the next line. I used \n because HTML will format it with an entire blank line between each line of 
                characters, which is better represented by \n. But it is easier to use an empty print statement and actually looks a little better, 
                I think.
            </p>
            <h3>Escape Sequences</h3>
            <p>
                Escape sequences represent special characters that you might want to include in a string but cannot type. To add a line break 
                in your string "red fish, blue fish old fish, new fish", you would include \n in the spot where you want the line to break. 
                The \n comes from the word newline, which is what people use to refer to this escape sequence. The result of adding a newline 
                in the example given would be "red fish, blue fish \n old fish, new fish" which would print out this:
            </p>
            <p class="psuedo">
                red fish, blue fish<br>old fish, new fish
            </p>
            <p>
                Another escape sequence is tab or \t. This escape sequence is useful for making tables, because it aligns things in columns. 
                You can also manually type spaces into your string, but it is easier and more precise to use a \t because spaces do not 
                help you align anything. 
            </p>

            <h1>Conceptual Programming Ideas</h1>
            <p>
                This type of algorithm, where a sum variable is updated in a for loop for a certain number of times, is called the 
                accumulator pattern, because it is a very common format for a function.
            </p>
            <h3>Function Decomposition</h3>
            <p>
                Function decomposition is not as cool as it sounds, because computer scientists love to come up with the genuinely coolest 
                names for stuff ever and then have it mean something so completely boring and useless. Function decomposition literally 
                just means breaking a problem down into smaller subproblems and using different functions on each subproblem that work 
                together to solve the problem. For example, if you wanted to add 2 squared to 3 cubed, you could use function decomposition 
                to split up the problem and make it more manageable. You could have a function that finds the square of any provided number  
                and a function that finds the cube of any provided number, then just call those on 2 and 3 respectively and add those results.
            </p>
            <h3>Function Composition</h3>
            <p>
                Function composition is the ability to build functions using other functions, or claling functions within other functions.
            </p>
            <h3>Flow of Execution</h3>
            <p>
                Flow of execution is another very cool name given to a mildly interesting topic. Flow execution refers to the order in which 
                lines of your code are called. Let's say you write a program which defines a function at the top and calls it at the bottom. 
                We will also only talk about interpreters in this case, as an interpreter is what will end up going line to line and doing 
                stuff. Your interpreter will start at the top of your code, working its way down. If it finds a function definition, it will 
                read the first line and parse it, but will see that it is a function declaration and jump to the line after the end of your 
                function. Now it will look at the line where you call the function and jump back up to where the function is 
                defined. It will then go back through that function, this time executing each step it reads. Then, once it completes the 
                function, it will return to where it originally was and continue moving down through your code. Since functions can call other 
                functions, this also leads to occasions where the interpreter goes down to the bottom where code is called, jumps to a function, 
                jumps to another function, runs that, goes back to the first function, runs that, and goes back to where the code is called.
            </p>
            <h3>How to Lay Out a Python Program</h3>
            <p>
                The official and proper way of formatting your Python program is as follows: imports, function declarations, declare main method, 
                call main method. It is also typical to declare variables at the top of any functions (including main method).
            </p>


            <h1>Keywords and Functions to Use While Coding</h1>
            <dl>
                <dt>print()</dt>
                <dd>
                    This function displays something on the screen. If you want to display a number or 
                    variable, you can say print(5) or print(variableName). If you want to print a specific 
                    string, use quotes such as in print("Hi!")
                </dd>
                <dt>type()</dt>
                <dd>
                    This function gives the data type of a variable. It does not print that information to 
                    the screen.
                </dd>
                <dt>len()</dt>
                <dd>
                    This function tells you the number of characters in a string or the number of elements in a 
                    list. It does not print that information to the screen.
                </dd>
                <dt>input()</dt>
                <dd>
                    This function asks the user for input. You can put a prompt string in the parenthesis which 
                    displays to the screen, and then the user returns the input as a string value.
                </dd>
                <dt>import __</dt>
                <dd>
                    This keyword is a command used to import a module.
                </dd>
                <dt>def __():</dt>
                <dd>
                    This is a keyword that allows you to define and write your own function. The name goes in the 
                    space where the underline is and any parameters go in the parenthesis. The code that you want 
                    the function to execute goes in an indented block below this line, and the indentation ends 
                    when your code wihtin the function ends. This allows the compiler/interpreter to understand 
                    what is part of your function and what is new code outside of it.
                </dd>
                <dt>abs()</dt>
                <dd>
                    This function returns the absolute value of a number provided in the parameter. It does not 
                    print this information.
                </dd>
                <dt>max()</dt>
                <dd>
                    This function returns the maximum value out of the list provided in the parameters. It does not 
                    print this information.
                </dd>
                <dt>range():</dt>
                <dd>
                    This function returns a sequence of numbers between 0 and a specified number within the 
                    parameter. There are also other ways to call range that allow you to start at a nonzero number. 
                    This method does not print the sequence. Also, this is often used in for loops along with a 
                    counter that moves through the sequence and stops the loop once it reaches the end.
                </dd>
                <dt>string[]</dt>
                <dd>
                    This keyword allows you to index into a string, ie get a subsection of the string by using 
                    index numbers. Specifically, use the name of the variable containing the string followed by 
                    parenthesis. So in this case, the variable name must be string.
                </dd>
                <dt>string.upper()</dt>
                <dd>
                    This function turns a string to all uppercase letters. Use the name of the variable holding 
                    the string, not just string.
                </dd>
                <dt>string.lower()</dt>
                <dd>
                    This function turns a string to all lowercase letters. Use the name of the variable holding 
                    the string, not just string.
                </dd>
                <dt>string.format()</dt>
                <dd>
                    This function works on strings to add information to an existing string. When you define your 
                    string, use curly braces {} in the spot where you want to fill in information. Then, use 
                    .format() to add the information. A common way you'll see this work is having a string like 
                    greeting = "Hello {}!".format(name) and then name is a variable that asks the user to input 
                    their name, so that the final greeting is "Hello Sage!" or "Hello Io!" depending on the input. 
                    You can also put some special codes inside the braces to change how your result is displayed. 
                    For example, if you were filling in a number that represents a price, you would want it to show 
                    the correct amount of decimal places. You can put :.2f inside the curly braces, and it will 
                    round to two decimal places. You can change the number to have it round to that many digits 
                    instead. 
                </dd>
                <dt>ord()</dt>
                <dd>
                    This function checks the ordinal number of the first character.
                </dd>
                <dt>chr()</dt>
                <dd>
                    This function takes an ordinal number and turns it back into a character.
                </dd>
                <dt>append()</dt>
                <dd>
                    This function adds a new item to the end of a list, the item being whatever value you put in 
                    the parenthesis.
                </dd>
                <dt>insert()</dt>
                <dd>
                    This function takes two parameters. The first is an index number of the position in the list 
                    where you want ot insert an element. The second is the value you want to insert.
                </dd>
                <dt>pop()</dt>
                <dd>
                    This function can be used two ways. If you provide no parameter, it takes the last element of a 
                    list off and returns it. If you do provide a parameter, which would be an index number of a 
                    position in the list, it removes an element from that particular position in the list and returns 
                    that instead of just taking the last element from the list.
                </dd>
                <dt>sort()</dt>
                <dd>This function sorts a list.</dd>
                <dt>reverse()</dt>
                <dd>This function reverses the order of a list.</dd>
                <dt>index()</dt>
                <dd>
                    This function takes a value as a parameter and returns the index of the first occurance of this 
                    value in a list.
                </dd>
                <dt>count()</dt>
                <dd>
                    This function takes a value as a parameter and returns the number of occurances of that value in a list.
                </dd>
                <dt>remove()</dt>
                <dd>
                    This function takes a value as a parameter and removes the first occurance of that value in a list.
                </dd>
                <dt>split()</dt>
                <dd>
                    This function cna be used on a string to split the string into a list of strings. If you don't put anything 
                    in the parenthesis, it automatically splits on the spaces between words, but you can also add a parameter 
                    to specify where you would like it to split, such as at a particular letter or at every period. Whatever 
                    parameter you give will be the place where the string splits, but will not be included in the list of 
                    strings. It will be removed entirely.
                </dd>
                <dt>join()</dt>
                <dd>
                    This function is the opposite of split. You choose a string that you want to go between the elements, which 
                    is often called the glue. Then, you take a list of strings and do glue.join(list) which will combine the 
                    elements of the list into a single string with the glue between them.
                </dd>
                <dt>list()</dt>
                <dd>
                    This function takes a string and separates each individual character into elements in a list.
                </dd>
                <dt>open()</dt>
                <dd>
                    This function takes two parameters. The first is a filename, and the second is either "r" or "w". If you use 
                    "r", this tells the computer that you are opening a file with data already in it which you wish to read. If 
                    you use "w", this tells the computer to open an empty file and add data to it. "r" stands for read, and "w" 
                    for write.
                </dd>
                <dt>close()</dt>
                <dd>This function closes an open file.</dd>
                <dt>read()</dt>
                <dd>This function goes through the entire file at once.</dd>
                <dt>readline()</dt>
                <dd>This function reads only the next line, keeping it as a string.</dd>
                <dt>readlines()</dt>
                <dd>This function reads the entire file but keeps each line as a separate element in a list of strings.</dd>
                <dt>write()</dt>
                <dd>
                    This function takes a string as a parameter, which is the string that you want to add to an open file.
                </dd>
                <dt>keys()</dt>
                <dd>
                    This function returns something called a 'view' of the keys in the dictionary, which looks like this: 
                    dict_keys(['apples', 'bananas', 'oranges', 'pears']). You can use the function list() to convert this to a 
                    normal list.
                </dd>
                <dt>values()</dt>
                <dd>
                    This function returns something called a 'view' of the values in the dictionary, which looks like this: 
                    dict_values(['apples', 'bananas', 'oranges', 'pears']). You can use the function list() to convert this to a 
                    normal list.
                </dd>
                <dt>items()</dt>
                <dd>
                    This function returns something called a 'view' of the key-value pairs in the dictionary, which looks like: 
                    dict_key_vals(['apples', 'bananas', 'oranges', 'pears']). You can use the function list() to convert this to a 
                    normal list.
                </dd>
                <dt>get()</dt>
                <dd>
                    This function takes a key as a parameter and returns the value at that key.
                </dd>
            </dl>
        </main>
        <footer>
            <p>source: <a href="https://runestone.academy/ns/books/published/thinkcspy/index.html">How to Think Like a Computer Scientist</a></p>        
        </footer>
        <script>
            function myFunction() {
                var elementBody = document.body;
                elementBody.classList.toggle("darkmode");
            }
        </script>
    </body>
</html>